package org.opentest4j.reporting.cli;

import org.opentest4j.reporting.schema.Namespace;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.w3c.dom.ls.LSInput;
import org.w3c.dom.ls.LSResourceResolver;
import org.xml.sax.ErrorHandler;
import org.xml.sax.SAXException;
import org.xml.sax.SAXParseException;
import picocli.CommandLine.Command;
import picocli.CommandLine.Option;
import picocli.CommandLine.Parameters;

import javax.xml.catalog.CatalogFeatures;
import javax.xml.catalog.CatalogManager;
import javax.xml.catalog.CatalogResolver;
import javax.xml.transform.Source;
import javax.xml.transform.stream.StreamSource;
import javax.xml.validation.SchemaFactory;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.Reader;
import java.net.URI;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.List;
import java.util.Map;
import java.util.concurrent.Callable;

import static java.util.Objects.requireNonNull;
import static javax.xml.XMLConstants.W3C_XML_SCHEMA_NS_URI;

@Command(
        name = "validate",
        description = "Validates XML report files"
)
public class ValidateCommand implements Callable<Integer> {

    private static final Logger LOG = LoggerFactory.getLogger(ValidateCommand.class);

    private static final Map<Namespace, String> SCHEMAS = Map.of(
            Namespace.REPORTING_EVENTS, "/org/opentest4j/reporting/schema/events.xsd",
            Namespace.REPORTING_HIERARCHY, "/org/opentest4j/reporting/schema/hierarchy.xsd",
            Namespace.REPORTING_CORE, "/org/opentest4j/reporting/schema/core.xsd",
            Namespace.REPORTING_JAVA, "/org/opentest4j/reporting/schema/java.xsd"
    );

    private final SchemaFactory schemaFactory = SchemaFactory.newInstance(W3C_XML_SCHEMA_NS_URI);

    @Parameters(arity = "1..*")
    List<Path> xmlFiles;

    @Option(names = "--catalogs")
    List<Path> catalogs = List.of();

    @Override
    public Integer call() {
        return validateAll() ? 0 : 1;
    }

    private boolean validateAll() {
        boolean valid = true;
        for (var xmlFile : xmlFiles) {
            valid &= validate(xmlFile);
        }
        return valid;
    }

    private boolean validate(Path xmlFile) {
        try (var in = Files.newInputStream(xmlFile)) {
            return validateSafely(xmlFile, new StreamSource(in));
        } catch (Exception e) {
            LOG.error("Failure during validation: {}", xmlFile, e);
            return false;
        }
    }

    private boolean validateSafely(Path xmlFile, Source source) throws SAXException, IOException {
        var errorHandler = new CollectingErrorHandler(xmlFile);
        validate(source, errorHandler);
        if (errorHandler.errors == 0) {
            LOG.info("Valid: {}", xmlFile);
            return true;
        } else {
            LOG.info("Invalid ({} {}): {}", errorHandler.errors, errorHandler.errors == 1 ? "error" : "errors", xmlFile);
            return false;
        }
    }

    private void validate(Source source, ErrorHandler errorHandler) throws SAXException, IOException {
        var validator = schemaFactory.newSchema().newValidator();
        validator.setResourceResolver(createResourceResolver());
        validator.setErrorHandler(errorHandler);
        validator.validate(source);
    }

    private LSResourceResolver createResourceResolver() {
        CatalogResolver catalogResolver = createCatalogResolver();
        return (type, namespaceURI, publicId, systemId, baseURI) -> {
            if (namespaceURI != null) {
                var namespace = Namespace.of(namespaceURI);
                if (SCHEMAS.containsKey(namespace)) {
                    LSInputImpl input = new LSInputImpl();
                    input.setPublicId(publicId);
                    input.setSystemId(requireNonNull(ValidateCommand.class.getResource(SCHEMAS.get(namespace))).toExternalForm());
                    input.setBaseURI(baseURI);
                    var stream = ValidateCommand.class.getResourceAsStream(SCHEMAS.get(namespace));
                    input.setCharacterStream(new InputStreamReader(requireNonNull(stream)));
                    return input;
                }
            }
            if (systemId != null) {
                return catalogResolver.resolveResource(type, namespaceURI, publicId, systemId, baseURI);
            }
            return null;
        };
    }

    private CatalogResolver createCatalogResolver() {
        var catalogs = this.catalogs.stream().map(Path::toUri).toArray(URI[]::new);
        return CatalogManager.catalogResolver(CatalogFeatures.defaults(), catalogs);
    }

    static class LSInputImpl implements LSInput {

        private Reader characterStream;
        private InputStream byteStream;
        private String stringData;
        private String systemId;
        private String publicId;
        private String baseURI;
        private String encoding;
        private boolean certifiedText;

        @Override
        public Reader getCharacterStream() {
            return characterStream;
        }

        @Override
        public void setCharacterStream(Reader characterStream) {
            this.characterStream = characterStream;
        }

        @Override
        public InputStream getByteStream() {
            return byteStream;
        }

        @Override
        public void setByteStream(InputStream byteStream) {
            this.byteStream = byteStream;
        }

        @Override
        public String getStringData() {
            return stringData;
        }

        @Override
        public void setStringData(String stringData) {
            this.stringData = stringData;
        }

        @Override
        public String getSystemId() {
            return systemId;
        }

        @Override
        public void setSystemId(String systemId) {
            this.systemId = systemId;
        }

        @Override
        public String getPublicId() {
            return publicId;
        }

        @Override
        public void setPublicId(String publicId) {
            this.publicId = publicId;
        }

        @Override
        public String getBaseURI() {
            return baseURI;
        }

        @Override
        public void setBaseURI(String baseURI) {
            this.baseURI = baseURI;
        }

        @Override
        public String getEncoding() {
            return encoding;
        }

        @Override
        public void setEncoding(String encoding) {
            this.encoding = encoding;
        }

        @Override
        public boolean getCertifiedText() {
            return certifiedText;
        }

        @Override
        public void setCertifiedText(boolean certifiedText) {
            this.certifiedText = certifiedText;
        }
    }

    private static class CollectingErrorHandler implements ErrorHandler {
        private final Path xmlFile;
        private int errors;

        public CollectingErrorHandler(Path xmlFile) {
            this.xmlFile = xmlFile;
        }

        @Override
        public void warning(SAXParseException e) {
            LOG.warn("{}:{}:{}\n{}", getLocation(e), e.getLineNumber(), e.getColumnNumber(), e.getMessage());
        }

        @Override
        public void error(SAXParseException e) {
            errors++;
            LOG.error("{}:{}:{}\n{}", getLocation(e), e.getLineNumber(), e.getColumnNumber(), e.getMessage());
        }

        private String getLocation(SAXParseException e) {
            return e.getSystemId() == null ? xmlFile.toString() : e.getSystemId();
        }

        @Override
        public void fatalError(SAXParseException e) throws SAXParseException {
            throw e;
        }
    }
}
