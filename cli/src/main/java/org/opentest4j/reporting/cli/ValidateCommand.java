package org.opentest4j.reporting.cli;

import org.opentest4j.reporting.events.api.Namespace;
import org.opentest4j.reporting.events.core.CoreFactory;
import org.opentest4j.reporting.events.java.JavaFactory;
import org.opentest4j.reporting.events.node.EventFactory;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.w3c.dom.ls.LSInput;
import org.xml.sax.ErrorHandler;
import org.xml.sax.SAXParseException;
import picocli.CommandLine.Command;
import picocli.CommandLine.Option;
import picocli.CommandLine.Parameters;

import javax.xml.catalog.CatalogFeatures;
import javax.xml.catalog.CatalogManager;
import javax.xml.catalog.CatalogResolver;
import javax.xml.transform.stream.StreamSource;
import javax.xml.validation.SchemaFactory;
import javax.xml.validation.Validator;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.Reader;
import java.net.URI;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.List;
import java.util.Map;
import java.util.concurrent.Callable;

import static java.util.Objects.requireNonNull;
import static javax.xml.XMLConstants.W3C_XML_SCHEMA_NS_URI;

@Command(
        name = "validate",
        description = "Validates XML report files"
)
public class ValidateCommand implements Callable<Integer> {

    private static final Logger LOG = LoggerFactory.getLogger(ValidateCommand.class);

    private static final Map<Namespace, String> SCHEMAS = Map.of(
            EventFactory.NAMESPACE, "/org/opentest4j/reporting/schema/events.xsd",
            CoreFactory.NAMESPACE, "/org/opentest4j/reporting/schema/core.xsd",
            JavaFactory.NAMESPACE, "/org/opentest4j/reporting/schema/java.xsd"
    );

    @Parameters(arity = "1..*")
    List<Path> xmlFiles;

    @Option(names = "--catalogs")
    List<Path> catalogs = List.of();

    @Override
    public Integer call() {
        var validator = createValidator();
        boolean errored = false;
        for (var xmlFile : xmlFiles) {
            var errorHandler = new CollectingErrorHandler(xmlFile);
            validator.setErrorHandler(errorHandler);
            try (var in = Files.newInputStream(xmlFile)) {
                validator.validate(new StreamSource(in));
            } catch (Exception e) {
                LOG.error("Failed to validate {}", xmlFile, e);
                errored = true;
            }
            if (errorHandler.errors == 0) {
                LOG.info("âœ… Valid: {}", xmlFile);
            }
            errored |= errorHandler.errors > 0;
        }
        return errored ? 1 : 0;
    }

    private Validator createValidator() {
        try {
            SchemaFactory schemaFactory = SchemaFactory.newInstance(W3C_XML_SCHEMA_NS_URI);
            var validator = schemaFactory.newSchema().newValidator();
            CatalogResolver catalogResolver = createCatalogResolver();
            validator.setResourceResolver((type, namespaceURI, publicId, systemId, baseURI) -> {
                if (namespaceURI != null) {
                    var namespace = Namespace.of(namespaceURI);
                    if (SCHEMAS.containsKey(namespace)) {
                        LSInputImpl input = new LSInputImpl();
                        input.setPublicId(publicId);
                        input.setSystemId(systemId);
                        input.setBaseURI(baseURI);
                        var stream = ValidateCommand.class.getResourceAsStream(SCHEMAS.get(namespace));
                        input.setCharacterStream(new InputStreamReader(requireNonNull(stream)));
                        return input;
                    }
                    return catalogResolver.resolveResource(
                            type,
                            namespaceURI,
                            publicId == null ? namespaceURI : publicId,
                            systemId == null ? namespaceURI : systemId,
                            baseURI
                    );
                }
                return null;
            });
            return validator;
        } catch (Exception e) {
            throw new RuntimeException("Failed to create schema", e);
        }
    }

    private CatalogResolver createCatalogResolver() {
        var catalogs = this.catalogs.stream().map(Path::toUri).toArray(URI[]::new);
        return CatalogManager.catalogResolver(CatalogFeatures.defaults(), catalogs);
    }

    static class LSInputImpl implements LSInput {

        private Reader characterStream;
        private InputStream byteStream;
        private String stringData;
        private String systemId;
        private String publicId;
        private String baseURI;
        private String encoding;
        private boolean certifiedText;

        @Override
        public Reader getCharacterStream() {
            return characterStream;
        }

        @Override
        public void setCharacterStream(Reader characterStream) {
            this.characterStream = characterStream;
        }

        @Override
        public InputStream getByteStream() {
            return byteStream;
        }

        @Override
        public void setByteStream(InputStream byteStream) {
            this.byteStream = byteStream;
        }

        @Override
        public String getStringData() {
            return stringData;
        }

        @Override
        public void setStringData(String stringData) {
            this.stringData = stringData;
        }

        @Override
        public String getSystemId() {
            return systemId;
        }

        @Override
        public void setSystemId(String systemId) {
            this.systemId = systemId;
        }

        @Override
        public String getPublicId() {
            return publicId;
        }

        @Override
        public void setPublicId(String publicId) {
            this.publicId = publicId;
        }

        @Override
        public String getBaseURI() {
            return baseURI;
        }

        @Override
        public void setBaseURI(String baseURI) {
            this.baseURI = baseURI;
        }

        @Override
        public String getEncoding() {
            return encoding;
        }

        @Override
        public void setEncoding(String encoding) {
            this.encoding = encoding;
        }

        @Override
        public boolean getCertifiedText() {
            return certifiedText;
        }

        @Override
        public void setCertifiedText(boolean certifiedText) {
            this.certifiedText = certifiedText;
        }
    }

    private static class CollectingErrorHandler implements ErrorHandler {
        private final Path xmlFile;
        private int errors;

        public CollectingErrorHandler(Path xmlFile) {
            this.xmlFile = xmlFile;
        }

        @Override
        public void warning(SAXParseException e) {
            LOG.warn("{}:{}:{}\n{}", xmlFile, e.getLineNumber(), e.getColumnNumber(), e.getMessage());
        }

        @Override
        public void error(SAXParseException e) {
            errors++;
            LOG.error("{}:{}:{}\n{}", xmlFile, e.getLineNumber(), e.getColumnNumber(), e.getMessage());
        }

        @Override
        public void fatalError(SAXParseException e) throws SAXParseException {
            throw e;
        }
    }
}
