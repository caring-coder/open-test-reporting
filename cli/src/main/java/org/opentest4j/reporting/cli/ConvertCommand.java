package org.opentest4j.reporting.cli;

import org.opentest4j.reporting.events.core.Infrastructure;
import org.opentest4j.reporting.events.root.Finished;
import org.opentest4j.reporting.events.root.Reported;
import org.opentest4j.reporting.events.root.Started;
import org.opentest4j.reporting.schema.Namespace;
import org.opentest4j.reporting.schema.QualifiedName;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.NamedNodeMap;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import picocli.CommandLine.Command;
import picocli.CommandLine.Parameters;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.transform.OutputKeys;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;
import java.nio.file.Path;
import java.time.Duration;
import java.time.Instant;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.Callable;
import java.util.function.BiPredicate;

import static javax.xml.XMLConstants.FEATURE_SECURE_PROCESSING;
import static javax.xml.XMLConstants.XMLNS_ATTRIBUTE;
import static javax.xml.XMLConstants.XMLNS_ATTRIBUTE_NS_URI;

@Command(
        name = "convert",
        description = "Converts from the event-based to the hierarchical XML format"
)
public class ConvertCommand implements Callable<Integer> {

    private static final String HIERARCHY_PREFIX = "h";
    public static final String CHILD_NODE_NAME = HIERARCHY_PREFIX + ":child";

    private static final Logger LOG = LoggerFactory.getLogger(ConvertCommand.class);

    @Parameters(arity = "1")
    Path eventsXml;

    @Override
    public Integer call() throws Exception {
        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
        factory.setNamespaceAware(true);
        DocumentBuilder builder = factory.newDocumentBuilder();

        Document sourceDocument = builder.parse(eventsXml.toFile());
        Node sourceRoot = sourceDocument.getDocumentElement();

        Document targetDocument = builder.newDocument();
        createRootElement(sourceRoot, targetDocument);

        Map<String, Element> nodeById = new HashMap<>();

        for (Node child = sourceRoot.getFirstChild(); child != null; child = child.getNextSibling()) {
            if (child instanceof Element) {
                Element element = (Element) child;
                if (matches(Started.ELEMENT, element)) {
                    started(targetDocument, nodeById, element);
                } else if (matches(Reported.ELEMENT, element)) {
                    reported(nodeById, element);
                } else if (matches(Finished.ELEMENT, element)) {
                    finished(nodeById, element);
                } else if (matches(Infrastructure.ELEMENT, element)) {
                    infrastructure(targetDocument, element);
                }
            }
        }

        TransformerFactory transformerFactory = TransformerFactory.newInstance();
        transformerFactory.setFeature(FEATURE_SECURE_PROCESSING, true);
        Transformer transformer = transformerFactory.newTransformer();
        transformer.setOutputProperty(OutputKeys.INDENT, "yes");
        transformer.setOutputProperty("{http://xml.apache.org/xslt}indent-amount", "2");

        Path targetFile = eventsXml.resolveSibling("execution.xml");
        transformer.transform(new DOMSource(targetDocument), new StreamResult(targetFile.toFile()));

        LOG.info("Converted {} to {}", eventsXml, targetFile);

        return 0;
    }

    private void createRootElement(Node sourceRoot, Document targetDocument) {
        Element targetRoot = targetDocument.createElement(HIERARCHY_PREFIX + ":execution");
        targetDocument.appendChild(targetRoot);

        copyAttributes(sourceRoot, targetRoot, (__, value) -> !Namespace.REPORTING_EVENTS.getUri().equals(value));
        targetRoot.setAttributeNS(XMLNS_ATTRIBUTE_NS_URI, XMLNS_ATTRIBUTE + ":" + HIERARCHY_PREFIX, Namespace.REPORTING_HIERARCHY.getUri());
    }

    private boolean matches(QualifiedName qualifiedName, Element element) {
        return qualifiedName.getNamespace().getUri().equals(element.getNamespaceURI())
                && qualifiedName.getName().equals(element.getLocalName());
    }

    private void infrastructure(Document targetDocument, Element sourceElement) {
        Node targetElement = sourceElement.cloneNode(true);
        targetDocument.adoptNode(targetElement);
        targetDocument.getDocumentElement().appendChild(targetElement);
    }

    private void started(Document targetDocument, Map<String, Element> nodeById, Element sourceElement) {
        Element targetElement;
        if (sourceElement.hasAttribute("parentId")) {
            targetElement = targetDocument.createElementNS(Namespace.REPORTING_HIERARCHY.getUri(), CHILD_NODE_NAME);
            nodeById.get(sourceElement.getAttribute("parentId")).appendChild(targetElement);
        } else {
            targetElement = targetDocument.createElementNS(Namespace.REPORTING_HIERARCHY.getUri(), HIERARCHY_PREFIX + ":root");
            targetDocument.getDocumentElement().appendChild(targetElement);
        }

        String id = sourceElement.getAttribute("id");
        nodeById.put(id, targetElement);

        copyAttributes(sourceElement, targetElement, (name, __) -> !"id".equals(name) && !"parentId".equals(name) && !"time".equals(name));
        copyChildren(sourceElement, targetElement);

        if (sourceElement.hasAttribute("time")) {
            targetElement.setAttribute("start", sourceElement.getAttribute("time"));
        }
    }

    private void reported(Map<String, Element> nodeById, Element sourceElement) {
        Element targetElement = nodeById.get(sourceElement.getAttribute("id"));
        copyAttributes(sourceElement, targetElement, (name, __) -> !"id".equals(name) && !"time".equals(name));
        // TODO merge properly
        copyChildren(sourceElement, targetElement);
    }

    private void finished(Map<String, Element> nodeById, Element sourceElement) {
        Element targetElement = nodeById.get(sourceElement.getAttribute("id"));

        copyAttributes(sourceElement, targetElement, (name, __) -> !"id".equals(name) && !"time".equals(name));

        // TODO merge properly
        copyChildren(sourceElement, targetElement);

        if (targetElement.hasAttribute("start") && sourceElement.hasAttribute("time")) {
            Instant start = Instant.parse(targetElement.getAttribute("start"));
            Instant finish = Instant.parse(sourceElement.getAttribute("time"));
            targetElement.setAttribute("duration", Duration.between(start, finish).toString());
        }

        moveChildrenToEnd(targetElement);
    }

    private void moveChildrenToEnd(Element targetElement) {
        var children = targetElement.getChildNodes();
        var candidates = new ArrayList<Node>(children.getLength());
        for (int i = 0; i < children.getLength(); i++) {
            var child = children.item(i);
            if (CHILD_NODE_NAME.equals(child.getNodeName())) {
                candidates.add(child);
            }
        }
        candidates.forEach(child -> {
            targetElement.removeChild(child);
            targetElement.appendChild(child);
        });
    }

    private void copyAttributes(Node sourceNode, Node targetNode, BiPredicate<String, String> filter) {
        NamedNodeMap sourceAttributes = sourceNode.getAttributes();
        for (int i = 0; i < sourceAttributes.getLength(); i++) {
            Node sourceItem = sourceAttributes.item(i);
            if (filter.test(sourceItem.getNodeName(), sourceItem.getNodeValue())) {
                Node targetItem = sourceItem.cloneNode(true);
                targetNode.getOwnerDocument().adoptNode(targetItem);
                targetNode.getAttributes().setNamedItem(targetItem);
            }
        }
    }

    private void copyChildren(Element sourceElement, Element targetElement) {
        NodeList childNodes = sourceElement.getChildNodes();
        for (int i = 0; i < childNodes.getLength(); i++) {
            Node sourceChild = childNodes.item(i);
            Node targetChild = sourceChild.cloneNode(true);
            targetElement.getOwnerDocument().adoptNode(targetChild);
            targetElement.appendChild(targetChild);
        }
    }
}
