package org.opentest4j.reporting.cli;

import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.NamedNodeMap;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import picocli.CommandLine.Command;
import picocli.CommandLine.Parameters;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.transform.OutputKeys;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;
import java.nio.file.Path;
import java.time.Duration;
import java.time.Instant;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.LinkedHashSet;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.Callable;
import java.util.function.Predicate;

import static javax.xml.XMLConstants.FEATURE_SECURE_PROCESSING;

@Command(
        name = "convert-events",
        description = "Converts from the event-based to the hierarchical XML format"
)
public class ConvertEventsCommand implements Callable<Integer> {

    @Parameters(arity = "1")
    Path eventsXml;

    @Override
    public Integer call() throws Exception {
        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
        factory.setNamespaceAware(true);
        DocumentBuilder builder = factory.newDocumentBuilder();

        Document sourceDocument = builder.parse(eventsXml.toFile());
        Node sourceRoot = sourceDocument.getFirstChild();

        Document targetDocument = builder.newDocument();
        org.w3c.dom.Element targetRoot = targetDocument.createElement("execution");
        targetDocument.appendChild(targetRoot);

        copyAttributes(sourceRoot, targetRoot, __ -> true);

        Map<String, Element> nodeById = new HashMap<>();

        for (Node child = sourceRoot.getFirstChild(); child != null; child = child.getNextSibling()) {
            if (child instanceof Element) {
                Element sourceElement = (Element) child;
                if ("started".equals(sourceElement.getTagName())) {

                    Element targetElement;
                    if (sourceElement.hasAttribute("parentId")) {
                        targetElement = targetDocument.createElement("child");
                        nodeById.get(sourceElement.getAttribute("parentId")).appendChild(targetElement);
                    } else {
                        targetElement = targetDocument.createElement("root");
                        targetRoot.appendChild(targetElement);
                    }

                    String id = sourceElement.getAttribute("id");
                    nodeById.put(id, targetElement);

                    copyAttributes(sourceElement, targetElement, name -> !"id".equals(name) && !"parentId".equals(name) && !"time".equals(name));
                    copyChildren(sourceElement, targetElement);

                    if (sourceElement.hasAttribute("time")) {
                        targetElement.setAttribute("start", sourceElement.getAttribute("time"));
                    }
                } else if ("reported".equals(sourceElement.getTagName())) {
                    Element targetElement = nodeById.get(sourceElement.getAttribute("id"));
                    copyAttributes(sourceElement, targetElement, name -> !"id".equals(name) && !"time".equals(name));
                    // TODO merge properly
                    copyChildren(sourceElement, targetElement);
                } else if ("finished".equals(sourceElement.getTagName())) {
                    Element targetElement = nodeById.get(sourceElement.getAttribute("id"));

                    copyAttributes(sourceElement, targetElement, name -> !"id".equals(name) && !"time".equals(name));

                    // TODO merge properly
                    copyChildren(sourceElement, targetElement);

                    if (targetElement.hasAttribute("start") && sourceElement.hasAttribute("time")) {
                        Instant start = Instant.parse(targetElement.getAttribute("start"));
                        Instant finish = Instant.parse(sourceElement.getAttribute("time"));
                        targetElement.setAttribute("duration", Duration.between(start, finish).toString());
                    }
                }
            }
        }

        TransformerFactory transformerFactory = TransformerFactory.newInstance();
        transformerFactory.setFeature(FEATURE_SECURE_PROCESSING, true);
        Transformer transformer = transformerFactory.newTransformer();
        transformer.setOutputProperty(OutputKeys.INDENT, "yes");
        transformer.setOutputProperty("{http://xml.apache.org/xslt}indent-amount", "2");

        Path targetFile = eventsXml.resolveSibling("execution.xml");
        transformer.transform(new DOMSource(targetDocument), new StreamResult(targetFile.toFile()));

        return 0;
    }

    private void copyAttributes(Node sourceNode, Node targetNode, Predicate<String> filter) {
        NamedNodeMap sourceAttributes = sourceNode.getAttributes();
        for (int i = 0; i < sourceAttributes.getLength(); i++) {
            Node sourceItem = sourceAttributes.item(i);
            if (filter.test(sourceItem.getNodeName())) {
                Node targetItem = sourceItem.cloneNode(true);
                targetNode.getOwnerDocument().adoptNode(targetItem);
                targetNode.getAttributes().setNamedItem(targetItem);
            }
        }
    }

    private void copyChildren(Element sourceElement, Element targetElement) {
        NodeList childNodes = sourceElement.getChildNodes();
        for (int i = 0; i < childNodes.getLength(); i++) {
            Node sourceChild = childNodes.item(i);
            Node targetChild = sourceChild.cloneNode(true);
            targetElement.getOwnerDocument().adoptNode(targetChild);
            targetElement.appendChild(targetChild);
        }
    }
}
