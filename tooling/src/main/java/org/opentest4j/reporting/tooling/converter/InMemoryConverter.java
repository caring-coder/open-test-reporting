package org.opentest4j.reporting.tooling.converter;

import org.opentest4j.reporting.events.core.Infrastructure;
import org.opentest4j.reporting.events.root.Event;
import org.opentest4j.reporting.events.root.Finished;
import org.opentest4j.reporting.events.root.Reported;
import org.opentest4j.reporting.events.root.Started;
import org.opentest4j.reporting.schema.Namespace;
import org.opentest4j.reporting.schema.QualifiedName;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.NamedNodeMap;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.transform.OutputKeys;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;
import java.nio.file.Path;
import java.time.Duration;
import java.time.Instant;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;
import java.util.Optional;
import java.util.Set;
import java.util.function.BiPredicate;
import java.util.stream.Stream;

import static java.util.stream.Collectors.toUnmodifiableSet;
import static javax.xml.XMLConstants.FEATURE_SECURE_PROCESSING;
import static javax.xml.XMLConstants.XMLNS_ATTRIBUTE;
import static javax.xml.XMLConstants.XMLNS_ATTRIBUTE_NS_URI;

public class InMemoryConverter implements Converter {

    private static final String HIERARCHY_PREFIX = "h";

    private static final String EXECUTION_NODE_NAME = HIERARCHY_PREFIX + ":execution";
    private static final String ROOT_NODE_NAME = HIERARCHY_PREFIX + ":root";
    private static final String CHILD_NODE_NAME = HIERARCHY_PREFIX + ":child";

    private static final String START_ATTRIBUTE_NAME = "start";
    private static final String DURATION_ATTRIBUTE_NAME = "duration";

    private static final Set<String> EVENT_ONLY_ATTRIBUTES = Stream.of(Event.ID, Event.TIME, Started.PARENT_ID)
            .map(QualifiedName::getName)
            .collect(toUnmodifiableSet());

    @Override
    public void convert(Path eventsXmlFile, Path hierarchicalXmlFile) throws Exception {

        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
        factory.setNamespaceAware(true);
        DocumentBuilder builder = factory.newDocumentBuilder();

        Document sourceDocument = builder.parse(eventsXmlFile.toFile());
        Node sourceRoot = sourceDocument.getDocumentElement();

        Document targetDocument = builder.newDocument();
        createRootElement(sourceRoot, targetDocument);

        Map<String, Element> nodeById = new HashMap<>();

        for (Node child = sourceRoot.getFirstChild(); child != null; child = child.getNextSibling()) {
            if (child instanceof Element) {
                Element element = (Element) child;
                if (matches(Started.ELEMENT, element)) {
                    started(targetDocument, nodeById, element);
                } else if (matches(Reported.ELEMENT, element)) {
                    reported(nodeById, element);
                } else if (matches(Finished.ELEMENT, element)) {
                    finished(nodeById, element);
                } else if (matches(Infrastructure.ELEMENT, element)) {
                    infrastructure(targetDocument, element);
                }
            }
        }

        TransformerFactory transformerFactory = TransformerFactory.newInstance();
        transformerFactory.setFeature(FEATURE_SECURE_PROCESSING, true);
        Transformer transformer = transformerFactory.newTransformer();
        transformer.setOutputProperty(OutputKeys.INDENT, "yes");
        transformer.setOutputProperty("{http://xml.apache.org/xslt}indent-amount", "2");

        transformer.transform(new DOMSource(targetDocument), new StreamResult(hierarchicalXmlFile.toFile()));
    }

    private void createRootElement(Node sourceRoot, Document targetDocument) {
        Element targetRoot = targetDocument.createElement(EXECUTION_NODE_NAME);
        targetDocument.appendChild(targetRoot);

        copyAttributes(sourceRoot, targetRoot, (__, value) -> !Namespace.REPORTING_EVENTS.getUri().equals(value));
        targetRoot.setAttributeNS(XMLNS_ATTRIBUTE_NS_URI, XMLNS_ATTRIBUTE + ":" + HIERARCHY_PREFIX, Namespace.REPORTING_HIERARCHY.getUri());
    }

    private boolean matches(QualifiedName qualifiedName, Element element) {
        return qualifiedName.getNamespace().getUri().equals(element.getNamespaceURI())
                && qualifiedName.getName().equals(element.getLocalName());
    }

    private void infrastructure(Document targetDocument, Element sourceElement) {
        Node targetElement = sourceElement.cloneNode(true);
        targetDocument.adoptNode(targetElement);
        targetDocument.getDocumentElement().appendChild(targetElement);
    }

    private void started(Document targetDocument, Map<String, Element> nodeById, Element sourceElement) {
        Element targetElement;
        if (sourceElement.hasAttribute(Started.PARENT_ID.getName())) {
            targetElement = targetDocument.createElementNS(Namespace.REPORTING_HIERARCHY.getUri(), CHILD_NODE_NAME);
            nodeById.get(sourceElement.getAttribute(Started.PARENT_ID.getName())).appendChild(targetElement);
        } else {
            targetElement = targetDocument.createElementNS(Namespace.REPORTING_HIERARCHY.getUri(), ROOT_NODE_NAME);
            targetDocument.getDocumentElement().appendChild(targetElement);
        }

        String id = sourceElement.getAttribute(Event.ID.getName());
        nodeById.put(id, targetElement);

        copyAttributes(sourceElement, targetElement, (name, __) -> !EVENT_ONLY_ATTRIBUTES.contains(name));
        copyChildren(sourceElement, targetElement);

        if (sourceElement.hasAttribute(Event.TIME.getName())) {
            targetElement.setAttribute(START_ATTRIBUTE_NAME, sourceElement.getAttribute(Event.TIME.getName()));
        }
    }

    private void reported(Map<String, Element> nodeById, Element sourceElement) {
        Element targetElement = nodeById.get(sourceElement.getAttribute(Event.ID.getName()));
        copyAttributes(sourceElement, targetElement, (name, __) -> !EVENT_ONLY_ATTRIBUTES.contains(name));
        mergeChildren(sourceElement, targetElement);
    }

    private void finished(Map<String, Element> nodeById, Element sourceElement) {
        Element targetElement = nodeById.get(sourceElement.getAttribute(Event.ID.getName()));

        copyAttributes(sourceElement, targetElement, (name, __) -> !EVENT_ONLY_ATTRIBUTES.contains(name));

        mergeChildren(sourceElement, targetElement);

        if (targetElement.hasAttribute(START_ATTRIBUTE_NAME) && sourceElement.hasAttribute(Event.TIME.getName())) {
            Instant start = Instant.parse(targetElement.getAttribute(START_ATTRIBUTE_NAME));
            Instant finish = Instant.parse(sourceElement.getAttribute(Event.TIME.getName()));
            targetElement.setAttribute(DURATION_ATTRIBUTE_NAME, Duration.between(start, finish).toString());
        }

        moveChildrenToEnd(targetElement);
    }

    private void moveChildrenToEnd(Element targetElement) {
        var children = targetElement.getChildNodes();
        var candidates = new ArrayList<Node>(children.getLength());
        for (int i = 0; i < children.getLength(); i++) {
            var child = children.item(i);
            if (CHILD_NODE_NAME.equals(child.getNodeName())) {
                candidates.add(child);
            }
        }
        candidates.forEach(child -> {
            targetElement.removeChild(child);
            targetElement.appendChild(child);
        });
    }

    private void copyAttributes(Node sourceNode, Node targetNode, BiPredicate<String, String> filter) {
        NamedNodeMap sourceAttributes = sourceNode.getAttributes();
        for (int i = 0; i < sourceAttributes.getLength(); i++) {
            Node sourceItem = sourceAttributes.item(i);
            if (filter.test(sourceItem.getNodeName(), sourceItem.getNodeValue())) {
                Node targetItem = sourceItem.cloneNode(true);
                targetNode.getOwnerDocument().adoptNode(targetItem);
                targetNode.getAttributes().setNamedItem(targetItem);
            }
        }
    }

    private void mergeChildren(Node sourceElement, Node targetElement) {
        NodeList childNodes = sourceElement.getChildNodes();
        for (int i = 0; i < childNodes.getLength(); i++) {
            Node sourceChild = childNodes.item(i);
            findNode(targetElement.getChildNodes(), sourceChild.getNodeName()).ifPresentOrElse(
                    existingNode -> copyChildren(sourceChild, existingNode),
                    () -> {
                        Node targetChild = sourceChild.cloneNode(true);
                        targetElement.getOwnerDocument().adoptNode(targetChild);
                        targetElement.appendChild(targetChild);
                    }
            );
        }
    }

    private Optional<Node> findNode(NodeList nodes, String name) {
        for (int i = 0; i < nodes.getLength(); i++) {
            Node child = nodes.item(i);
            if (child.getNodeName().equals(name)) {
                return Optional.of(child);
            }
        }
        return Optional.empty();
    }

    private void copyChildren(Node sourceElement, Node targetElement) {
        NodeList childNodes = sourceElement.getChildNodes();
        for (int i = 0; i < childNodes.getLength(); i++) {
            Node sourceChild = childNodes.item(i);
            Node targetChild = sourceChild.cloneNode(true);
            targetElement.getOwnerDocument().adoptNode(targetChild);
            targetElement.appendChild(targetChild);
        }
    }
}
